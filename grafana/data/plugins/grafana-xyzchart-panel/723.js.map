{"version":3,"file":"723.js","mappings":"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","sources":["webpack:///./components/Camera.tsx","webpack:///./optionsContext.ts","webpack:///./components/PointHoverAxes.tsx","webpack:///./components/HUD.tsx","webpack:///./components/PointCloud.tsx","webpack:///./types.ts","webpack:///./components/Label.tsx","webpack:///./components/Axis.tsx","webpack:///./components/GridPlane.tsx","webpack:///./components/GridVolume.tsx","webpack:///./components/PlotCanvas.tsx"],"sourcesContent":["import React, { useEffect } from 'react';\nimport { PerspectiveCamera } from '@react-three/drei';\nimport { useThree, Vector3 } from '@react-three/fiber';\nimport { OrbitControls, MapControls } from 'three-stdlib';\nimport { SCENE_SCALE } from 'consts';\n\nexport const Camera: React.FC = () => {\n  const { camera, gl } = useThree();\n  const sceneScale = SCENE_SCALE;\n  let cameraPos: Vector3;\n  let lookAt: Vector3;\n\n  cameraPos = [sceneScale * 1.4, sceneScale - sceneScale / 2, sceneScale * 1.4];\n\n  lookAt = [0, 0, 0];\n\n  useEffect(() => {\n    let controls: OrbitControls | MapControls | null = null;\n\n    controls = new OrbitControls(camera, gl.domElement);\n    controls.minDistance = 3;\n    controls.maxDistance = sceneScale * 2;\n\n    // @ts-ignore\n    camera.position.set(...cameraPos);\n    // @ts-ignore\n    controls.target.set(...lookAt);\n    controls.update();\n\n    return () => {\n      if (controls !== null) {\n        controls.dispose();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [camera, gl, sceneScale]);\n\n  return <PerspectiveCamera fov={75} />;\n};\n","import React from 'react';\nimport { XYZChartOptions } from 'models.gen';\n\nconst opts: XYZChartOptions = {\n  pointColor: '',\n  pointSize: 0,\n  seriesMapping: 'auto',\n};\n\nconst OptionsContext = React.createContext(opts);\n\nexport const OptionsProvider = OptionsContext.Provider;\n\nexport default OptionsContext;\n","import { Line } from '@react-three/drei';\nimport OptionsContext from 'optionsContext';\nimport React, { useContext } from 'react';\nimport { Vector3 } from 'three';\nimport { XYZChartOptions } from 'models.gen';\n\ninterface PointHoverAxesProps {\n  pointVector: Vector3;\n}\n\nexport const PointHoverAxes = (props: PointHoverAxesProps) => {\n  const { pointVector } = props;\n\n  const options: XYZChartOptions = useContext(OptionsContext);\n\n  const upPlanePos: Vector3 = new Vector3(pointVector.x, pointVector.y, 0);\n  const forwardPlanePos: Vector3 = new Vector3(0, pointVector.y, pointVector.z);\n  const rightPlanePos: Vector3 = new Vector3(pointVector.x, 0, pointVector.z);\n\n  return (\n    <>\n      <Line points={[pointVector, upPlanePos]} color={options.themeColor} dashed={true} />\n      <Line points={[pointVector, forwardPlanePos]} color={options.themeColor} dashed={true} />\n      <Line points={[pointVector, rightPlanePos]} color={options.themeColor} dashed={true} />\n    </>\n  );\n};\n","import React, { useContext } from 'react';\nimport OptionsContext from 'optionsContext';\nimport { XYZChartOptions } from 'models.gen';\nimport { Html } from '@react-three/drei';\nimport { css } from '@emotion/css';\n\ninterface HUDProps {\n  pointPos: THREE.Vector3;\n  xValue: string;\n  yValue: string;\n  zValue: string;\n}\n\nexport const HUD: React.FC<HUDProps> = ({ pointPos, xValue, yValue, zValue }) => {\n  const options: XYZChartOptions = useContext(OptionsContext);\n  const styles = getStyles(options);\n\n  return (\n    <Html\n      position={pointPos}\n      style={{\n        transform: 'translate3d(-50%, -120%, 0)',\n      }}\n    >\n      <div className={styles.tooltip}>\n        <ul>\n          <li>{xValue}</li>\n          <li>{yValue}</li>\n          <li>{zValue}</li>\n        </ul>\n      </div>\n    </Html>\n  );\n};\n\nconst getStyles = (options: XYZChartOptions) => {\n  return {\n    tooltip: css`\n      padding: 10px;\n      background-color: ${options.hudBgColor};\n      text-align: left;\n      color: white;\n      ul {\n        list-style: none;\n        display: inline-block;\n        li {\n          white-space: nowrap;\n        }\n      }\n    `,\n  };\n};\n","import { hexToRgb } from '../utils';\nimport OptionsContext from 'optionsContext';\nimport React, { useRef, useState, useContext, useEffect, useCallback, RefObject, ReactNode } from 'react';\nimport { PointData, RGBColor } from 'types';\nimport { BufferAttribute, PointsMaterial, Vector3, BufferGeometry } from 'three';\nimport { useTexture } from '@react-three/drei';\nimport { PointHoverAxes } from './PointHoverAxes';\nimport { HUD } from './HUD';\nimport { DataFrame } from '@grafana/data';\nimport { XYZChartOptions } from 'models.gen';\n\ninterface Props {\n  points: PointData;\n  lights: Array<RefObject<ReactNode>>;\n  frames: DataFrame[];\n}\n\nexport const PointCloud: React.FC<Props> = ({ points, lights, frames }) => {\n  const pts: { geometry: BufferGeometry } = { geometry: new BufferGeometry() };\n  const ptsMat: PointsMaterial = new PointsMaterial();\n  const pointsRef = useRef(pts);\n  const materialRef = useRef(ptsMat);\n  const options: XYZChartOptions = useContext(OptionsContext);\n  const circleTexture = useTexture('/public/plugins/grafana-xyzchart-panel/img/dot.png');\n  const [hoveredPointPos, setHoveredStatePos] = useState<Vector3 | null>(null);\n  const [hoveredPointData, setHoveredPointData] = useState<string[]>([]);\n\n  useEffect(() => {\n    const color: RGBColor = hexToRgb(options.pointColor ?? '#ff0000');\n    const colorAttr = pointsRef.current.geometry.getAttribute('color');\n    for (let i = 0; i < colorAttr.array.length; i++) {\n      colorAttr.setXYZ(i, color.r, color.g, color.b);\n      colorAttr.needsUpdate = true;\n    }\n  }, [options.pointColor]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      materialRef.current.size = options.pointSize;\n      materialRef.current.needsUpdate = true;\n    }\n  }, [options.pointSize]);\n\n  useEffect(() => {\n    if (pointsRef.current) {\n      const posAttr = new BufferAttribute(points.points, 3);\n      const colorAttr = new BufferAttribute(points.colors, 3);\n      pointsRef.current.geometry.setAttribute('position', posAttr);\n      pointsRef.current.geometry.setAttribute('color', colorAttr);\n      pointsRef.current.geometry.attributes.position.needsUpdate = true;\n    }\n  }, [points]);\n\n  const hover = useCallback(\n    (e) => {\n      e.stopPropagation();\n      const colorAttr = pointsRef.current.geometry.getAttribute('color');\n      colorAttr.setXYZ(e.index, 1, 1, 1);\n      colorAttr.needsUpdate = true;\n      pointsRef.current.geometry.setAttribute('color', colorAttr);\n\n      let hudData = [];\n      for (let field of frames[0].fields) {\n        hudData.push(`${field.name}: ${field.values.get(e.index)}`);\n      }\n\n      setHoveredPointData(hudData);\n\n      const posAttr = pointsRef.current.geometry.getAttribute('position');\n      const pointPos = new Vector3(posAttr.getX(e.index), posAttr.getY(e.index), posAttr.getZ(e.index));\n\n      setHoveredStatePos(pointPos);\n    },\n    [frames]\n  );\n\n  const unhover = useCallback(\n    (e) => {\n      e.stopPropagation();\n\n      const color: RGBColor = hexToRgb(options.pointColor ?? '#ff0000');\n      const colorAttr = pointsRef.current.geometry.getAttribute('color');\n      colorAttr.setXYZ(e.index, color.r, color.g, color.b);\n      colorAttr.needsUpdate = true;\n      pointsRef.current.geometry.setAttribute('color', colorAttr);\n\n      setHoveredPointData([]);\n      setHoveredStatePos(null);\n    },\n    [options.pointColor]\n  );\n\n  return (\n    <>\n      <points ref={pointsRef} onPointerOver={hover} onPointerOut={unhover}>\n        <bufferGeometry attach=\"geometry\">\n          <bufferAttribute\n            attachObject={['attributes', 'position']}\n            count={points.points.length / 3}\n            array={points.points}\n            itemSize={3}\n          />\n          <bufferAttribute\n            attachObject={['attributes', 'color']}\n            count={points.colors.length / 3}\n            array={points.colors}\n            itemSize={3}\n          />\n        </bufferGeometry>\n        <pointsMaterial\n          ref={materialRef}\n          attach=\"material\"\n          opacity={1}\n          transparent\n          vertexColors\n          size={options.pointSize}\n          sizeAttenuation={true}\n          map={circleTexture}\n        />\n      </points>\n      {hoveredPointPos !== null && (\n        <>\n          <PointHoverAxes pointVector={hoveredPointPos} />\n          <HUD\n            pointPos={hoveredPointPos}\n            xValue={hoveredPointData[0]}\n            yValue={hoveredPointData[1]}\n            zValue={hoveredPointData[2]}\n          />\n        </>\n      )}\n    </>\n  );\n};\n","import { Euler } from '@react-three/fiber';\n\n/**\n * A simple point geometry in the format [x, y, z].\n */\nexport type PointGeometry = [number, number, number];\n\n/**\n * A simple line geometry with:\n * LineGeometry[0] --> Origin Point\n * LineGeometry[1] --> Destination Point\n */\nexport type LineGeometry = [PointGeometry, PointGeometry];\n\nexport interface LabelProps {\n  position: PointGeometry;\n  text: string;\n  rotation?: Euler;\n  direction: Direction;\n  labelSize?: number;\n}\n\nexport interface GridVolumeProps {\n  intervalLabels: IntervalLabels;\n}\n\nexport interface GridPlaneProps {\n  direction: Direction;\n  intervalLabels: any[];\n}\n\nexport enum Direction {\n  Up = 1,\n  Right,\n  Forward,\n}\n\nexport interface AxisData {\n  axisPoints: PointGeometry[];\n  intervalGeometries: number[][][];\n  intervalLabelPos: PointGeometry[];\n  labelRotation: Euler;\n  color: string;\n}\n\nexport interface PointData {\n  points: Float32Array;\n  colors: Float32Array;\n}\n\nexport interface IntervalLabels {\n  xLabels: string[];\n  yLabels: string[];\n  zLabels: string[];\n}\n\nexport interface RGBColor {\n  r: number;\n  g: number;\n  b: number;\n}\n","import React, { useContext } from 'react';\nimport { Text } from '@react-three/drei';\nimport { Direction, LabelProps } from 'types';\nimport { SCENE_SCALE, WHITE } from 'consts';\nimport OptionsContext from 'optionsContext';\nimport { XYZChartOptions } from 'models.gen';\n\nexport const Label = ({ direction, labelSize, position, rotation, text }: LabelProps) => {\n  const options: XYZChartOptions = useContext(OptionsContext);\n  const fontSize = labelSize ? labelSize : (SCENE_SCALE * 0.2) / 10;\n  const color = options.themeColor ?? WHITE;\n\n  // Negative percentages don't work beyond -100% hence using\n  // local units in that case instead\n  const anchorX = direction === Direction.Right ? '116%' : -1.15;\n\n  return (\n    <Text\n      color={color}\n      textAlign=\"left\"\n      //@ts-ignore\n      anchorX={anchorX}\n      fontSize={fontSize}\n      position={position}\n      rotation={rotation}\n    >\n      {text}\n    </Text>\n  );\n};\n","import { Line } from '@react-three/drei';\nimport { INTERVAL_INDEX_LENGTH, LABEL_DISTANCE_FROM_GRID, LABEL_INTERVAL, SCENE_SCALE, WHITE } from 'consts';\nimport { XYZChartOptions } from 'models.gen';\nimport OptionsContext from 'optionsContext';\nimport React, { useContext, useMemo, useCallback } from 'react';\nimport { Euler } from '@react-three/fiber';\nimport { Direction, GridPlaneProps, AxisData, PointGeometry, LineGeometry } from 'types';\nimport { Label } from './Label';\n\nexport const Axis: React.FC<GridPlaneProps> = ({ direction, intervalLabels }) => {\n  const options: XYZChartOptions = useContext(OptionsContext);\n\n  const getAxisData = useCallback(\n    (direction: Direction): AxisData => {\n      let startVec: PointGeometry, endVec: PointGeometry;\n      let labelRotation: Euler = [0, 0, 0];\n      const intervalGeometries: LineGeometry[] = [];\n      const intervalLabelPos: PointGeometry[] = [];\n      const color = options.themeColor ?? WHITE;\n\n      // Set start and end vectors\n      switch (direction) {\n        case Direction.Up:\n          startVec = [SCENE_SCALE, 0, 0];\n          endVec = [SCENE_SCALE, SCENE_SCALE, 0];\n          break;\n        case Direction.Forward:\n          startVec = [SCENE_SCALE, 0, 0];\n          endVec = [SCENE_SCALE, 0, SCENE_SCALE];\n          break;\n        case Direction.Right:\n          startVec = [0, 0, SCENE_SCALE];\n          endVec = [SCENE_SCALE, 0, SCENE_SCALE];\n          break;\n      }\n\n      for (let i = 0; i < SCENE_SCALE + LABEL_INTERVAL; i = i + LABEL_INTERVAL) {\n        switch (direction) {\n          case Direction.Up:\n            intervalGeometries.push([\n              [SCENE_SCALE, i, 0],\n              [SCENE_SCALE + (INTERVAL_INDEX_LENGTH * SCENE_SCALE) / 10, i, 0],\n            ]);\n\n            if (i === 0) {\n              intervalLabelPos.push([SCENE_SCALE + LABEL_DISTANCE_FROM_GRID, i + 0.5, -1]);\n            } else {\n              intervalLabelPos.push([SCENE_SCALE + LABEL_DISTANCE_FROM_GRID, i, 0]);\n            }\n\n            // Don't need to rotate the label in this case\n            break;\n          case Direction.Forward:\n            intervalGeometries.push([\n              [SCENE_SCALE, 0, i],\n              [SCENE_SCALE + (INTERVAL_INDEX_LENGTH * SCENE_SCALE) / 10, 0, i],\n            ]);\n\n            if (i === 0) {\n              intervalLabelPos.push([SCENE_SCALE + LABEL_DISTANCE_FROM_GRID, -0.5, i + 1]);\n            } else {\n              intervalLabelPos.push([SCENE_SCALE + LABEL_DISTANCE_FROM_GRID, 0, i]);\n            }\n\n            labelRotation = [-Math.PI / 2, 0, 0];\n            break;\n          case Direction.Right:\n            intervalGeometries.push([\n              [i, 0, SCENE_SCALE],\n              [i, 0, SCENE_SCALE + (INTERVAL_INDEX_LENGTH * SCENE_SCALE) / 10],\n            ]);\n            intervalLabelPos.push([i, 0, SCENE_SCALE + LABEL_DISTANCE_FROM_GRID]);\n            labelRotation = [-Math.PI / 2, 0, Math.PI / 2];\n            break;\n        }\n      }\n\n      const axisPoints = [startVec, endVec];\n\n      return { axisPoints, intervalGeometries, intervalLabelPos, labelRotation, color };\n    },\n    [options.themeColor]\n  );\n\n  const { axisPoints, intervalGeometries, intervalLabelPos, labelRotation, color } = useMemo(\n    () => getAxisData(direction),\n    [direction, getAxisData]\n  );\n\n  return (\n    <group key={'axis_' + direction}>\n      <Line points={axisPoints} color={color} lineWidth={2.5} dashed={false} />\n      {intervalGeometries.map((points, index) => {\n        return (\n          <group key={index}>\n            <Line points={points as Array<[number, number, number]>} color={color} lineWidth={2.5} dashed={false} />\n            <Label\n              direction={direction}\n              position={intervalLabelPos[index]}\n              text={intervalLabels[index]}\n              rotation={labelRotation}\n            />\n          </group>\n        );\n      })}\n    </group>\n  );\n};\n","import { AXIS_COLOR, LABEL_INTERVAL, SCENE_SCALE } from 'consts';\nimport React, { useMemo } from 'react';\nimport { Line } from '@react-three/drei';\nimport { Direction, GridPlaneProps, LineGeometry } from 'types';\nimport { Axis } from './Axis';\n\nexport const GridPlane: React.FC<GridPlaneProps> = ({ direction, intervalLabels }) => {\n  const createGeometry = (direction: Direction): LineGeometry[] => {\n    let lineGeometries: LineGeometry[] = [];\n\n    for (let i = 0; i < SCENE_SCALE; i = i + LABEL_INTERVAL) {\n      switch (direction) {\n        case Direction.Up:\n          lineGeometries.push([\n            [i, 0, 0],\n            [i, SCENE_SCALE, 0],\n          ]);\n          lineGeometries.push([\n            [0, i, 0],\n            [SCENE_SCALE, i, 0],\n          ]);\n          break;\n        case Direction.Right:\n          lineGeometries.push([\n            [0, 0, i],\n            [SCENE_SCALE, 0, i],\n          ]);\n          lineGeometries.push([\n            [i, 0, 0],\n            [i, 0, SCENE_SCALE],\n          ]);\n          break;\n        case Direction.Forward:\n          lineGeometries.push([\n            [0, i, 0],\n            [0, i, SCENE_SCALE],\n          ]);\n          lineGeometries.push([\n            [0, 0, i],\n            [0, SCENE_SCALE, i],\n          ]);\n          break;\n      }\n    }\n\n    return lineGeometries;\n  };\n  const lines = useMemo(() => createGeometry(direction), [direction]);\n\n  return (\n    <group>\n      {lines.map((lineGeo, index) => {\n        return <Line points={lineGeo} color={AXIS_COLOR} key={index} lineWidth={0.5} />;\n      })}\n      <Axis direction={direction} intervalLabels={intervalLabels} />\n    </group>\n  );\n};\n","import React from 'react';\nimport { Direction, GridVolumeProps } from 'types';\nimport { GridPlane } from './GridPlane';\n\nexport const GridVolume = ({ intervalLabels }: GridVolumeProps) => {\n  return (\n    <group>\n      <GridPlane direction={Direction.Up} intervalLabels={intervalLabels.yLabels} />\n      <GridPlane direction={Direction.Right} intervalLabels={intervalLabels.xLabels} />\n      <GridPlane direction={Direction.Forward} intervalLabels={intervalLabels.zLabels} />\n    </group>\n  );\n};\n","import { Html, useProgress } from '@react-three/drei';\nimport React, { createRef, useEffect, useState, RefObject, ReactNode, Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { DataFrame } from '@grafana/data';\n\nimport { Camera } from 'components/Camera';\nimport { getIntervalLabels, prepData } from 'utils';\nimport { WHITE } from 'consts';\nimport { XYZChartOptions } from 'models.gen';\nimport { OptionsProvider } from 'optionsContext';\nimport { PointCloud } from './PointCloud';\nimport { GridVolume } from './GridVolume';\ninterface Props {\n  frames: DataFrame[];\n  options: XYZChartOptions;\n}\n\nconst PlotCanvas: React.FC<Props> = ({ frames, options }) => {\n  let ambLightRef: RefObject<ReactNode> = createRef();\n  let pntLightRef: RefObject<ReactNode> = createRef();\n  const [pointData, setPointData] = useState(prepData(frames, options.pointColor ?? '#ff0000'));\n  const [intervalLabels, setIntervalLabels] = useState(getIntervalLabels(frames));\n\n  useEffect(() => {\n    const newLabels = getIntervalLabels(frames);\n\n    setIntervalLabels(newLabels);\n    setPointData(prepData(frames, options.pointColor ?? '#ff0000'));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [frames]);\n\n  function Loader() {\n    const { progress } = useProgress();\n    return <Html center>{progress} % loaded</Html>;\n  }\n\n  return (\n    <>\n      <Canvas mode=\"concurrent\" raycaster={{ params: { Points: { threshold: 2 } } }} linear flat>\n        {/* \n          Context does not work outside of Canvas. Seems Canvas is outside parent component in DOM \n          https://github.com/facebook/react/issues/17126\n        */}\n        <Suspense fallback={<Loader />}>\n          <OptionsProvider value={options}>\n            <Camera />\n            <ambientLight ref={ambLightRef} intensity={0.8} color={WHITE} />\n            <pointLight ref={pntLightRef} intensity={1.0} position={[10, 10, 10]} />\n            <Suspense fallback={null}>\n              <PointCloud frames={frames} points={pointData} lights={[ambLightRef, pntLightRef]} />\n            </Suspense>\n            <GridVolume intervalLabels={intervalLabels} />\n          </OptionsProvider>\n        </Suspense>\n      </Canvas>\n    </>\n  );\n};\n\nexport default PlotCanvas;\n"],"names":["Camera","camera","gl","useThree","sceneScale","SCENE_SCALE","cameraPos","lookAt","useEffect","controls","OrbitControls","domElement","minDistance","maxDistance","position","set","target","update","dispose","PerspectiveCamera","fov","OptionsContext","React","pointColor","pointSize","seriesMapping","OptionsProvider","Provider","PointHoverAxes","props","pointVector","options","useContext","upPlanePos","Vector3","x","y","forwardPlanePos","z","rightPlanePos","Line","points","color","themeColor","dashed","HUD","pointPos","xValue","yValue","zValue","styles","getStyles","Html","style","transform","div","className","tooltip","ul","li","css","hudBgColor","PointCloud","lights","frames","pts","geometry","BufferGeometry","ptsMat","PointsMaterial","pointsRef","useRef","materialRef","circleTexture","useTexture","hoveredPointPos","setHoveredStatePos","useState","hoveredPointData","setHoveredPointData","hexToRgb","colorAttr","current","getAttribute","i","array","length","setXYZ","r","g","b","needsUpdate","size","posAttr","BufferAttribute","colors","setAttribute","attributes","hover","useCallback","e","stopPropagation","index","hudData","field","fields","push","name","values","get","getX","getY","getZ","unhover","ref","onPointerOver","onPointerOut","bufferGeometry","attach","bufferAttribute","attachObject","count","itemSize","pointsMaterial","opacity","transparent","vertexColors","sizeAttenuation","map","Direction","Up","Right","Forward","Label","direction","labelSize","rotation","text","fontSize","WHITE","anchorX","Text","textAlign","Axis","intervalLabels","getAxisData","startVec","endVec","labelRotation","intervalGeometries","intervalLabelPos","LABEL_INTERVAL","LABEL_DISTANCE_FROM_GRID","Math","PI","axisPoints","useMemo","group","key","lineWidth","GridPlane","lines","lineGeometries","createGeometry","lineGeo","AXIS_COLOR","GridVolume","yLabels","xLabels","zLabels","ambLightRef","createRef","pntLightRef","pointData","setPointData","prepData","setIntervalLabels","getIntervalLabels","Loader","progress","useProgress","center","newLabels","Canvas","mode","raycaster","params","Points","threshold","linear","flat","Suspense","fallback","value","ambientLight","intensity","pointLight"],"sourceRoot":""}