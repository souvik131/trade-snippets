<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Market Data</title>
    <style>
      body {
        font-family: monospace;
        margin: 0;
        padding: 20px;
        background-color: #000;
        color: #fff;
      }

      .stock-row {
        display: grid;
        grid-template-columns: 100px 100px 100px 200px 200px 80px 200px;
        gap: 20px;
        padding: 10px;
        border-bottom: 1px solid #333;
        align-items: center;
      }

      .header {
        font-weight: bold;
        color: #888;
        border-bottom: 2px solid #444;
        position: sticky;
        top: 0;
        background-color: #000;
        z-index: 1;
      }

      .header > div {
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
      }

      .header > div:hover {
        color: #fff;
      }

      .sort-icon::after {
        content: "↕";
        margin-left: 5px;
        font-size: 0.8em;
      }

      .sort-asc::after {
        content: "↑";
      }

      .sort-desc::after {
        content: "↓";
      }

      .bid-ask {
        display: flex;
        gap: 10px;
      }

      .bid {
        color: #4caf50;
      }

      .ask {
        color: #f44336;
      }

      .lot-size {
        color: #888;
      }

      .exposure {
        color: #888;
      }

      #status {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 2;
      }

      .connected {
        background-color: #4caf50;
      }

      .disconnected {
        background-color: #f44336;
      }

      .connecting {
        background-color: #ffc107;
      }

      .stale {
        opacity: 0.5;
      }

      .timestamp {
        font-size: 0.8em;
        color: #666;
        margin-left: 10px;
      }

      #market-status {
        position: fixed;
        top: 40px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        background-color: #333;
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="status" class="disconnected">Disconnected</div>
    <div id="market-status">Market Closed</div>
    <div id="app">
      <div class="stock-row header">
        <div data-sort="name" class="sort-icon sort-asc">Stock</div>
        <div data-sort="future" class="sort-icon">Future</div>
        <div data-sort="strike" class="sort-icon">Strike</div>
        <div data-sort="ce" class="sort-icon">Call Bid / Ask</div>
        <div data-sort="pe" class="sort-icon">Put Bid / Ask</div>
        <div data-sort="lot" class="sort-icon">Lot</div>
        <div data-sort="exposure" class="sort-icon">Exposure</div>
      </div>
    </div>

    <script>
      class MarketDataUI {
        constructor() {
          this.app = document.getElementById("app");
          this.status = document.getElementById("status");
          this.marketStatus = document.getElementById("market-status");
          this.stockData = new Map();
          this.decoder = new TextDecoder();
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 5;
          this.reconnectDelay = 1000;
          this.currentSort = { column: "name", direction: "asc" };
          this.setupSortingListeners();
          this.connect();
          this.startStaleDataCheck();
        }

        formatIndianCurrency(number) {
          if (!number || isNaN(number)) return "-";

          const absNumber = Math.abs(number);
          if (absNumber >= 10000000) {
            // 1 crore
            return (number / 10000000).toFixed(2) + " Cr";
          } else if (absNumber >= 100000) {
            // 1 lakh
            return (number / 100000).toFixed(2) + " L";
          } else {
            return number.toFixed(2);
          }
        }

        setupSortingListeners() {
          const headers = document.querySelectorAll(".header > div");
          headers.forEach((header) => {
            header.addEventListener("click", () => {
              const column = header.dataset.sort;
              if (this.currentSort.column === column) {
                this.currentSort.direction =
                  this.currentSort.direction === "asc" ? "desc" : "asc";
              } else {
                this.currentSort.column = column;
                this.currentSort.direction = "asc";
              }

              // Update sort icons
              headers.forEach((h) => {
                h.classList.remove("sort-asc", "sort-desc");
                if (h.dataset.sort === this.currentSort.column) {
                  h.classList.add(
                    this.currentSort.direction === "asc"
                      ? "sort-asc"
                      : "sort-desc"
                  );
                }
              });

              this.sortAndRenderRows();
            });
          });
        }

        sortAndRenderRows() {
          const rows = Array.from(
            document.querySelectorAll(".stock-row:not(.header)")
          );
          const sortedStocks = Array.from(this.stockData.entries()).sort(
            (a, b) => {
              const [nameA, dataA] = a;
              const [nameB, dataB] = b;

              let comparison = 0;
              switch (this.currentSort.column) {
                case "name":
                  comparison = nameA.localeCompare(nameB);
                  break;
                case "future":
                  comparison = (dataA.future || 0) - (dataB.future || 0);
                  break;
                case "strike":
                  comparison = (dataA.strike || 0) - (dataB.strike || 0);
                  break;
                case "lot":
                  comparison = (dataA.lotSize || 0) - (dataB.lotSize || 0);
                  break;
                case "exposure":
                  const expA = (dataA.lotSize || 0) * (dataA.future || 0);
                  const expB = (dataB.lotSize || 0) * (dataB.future || 0);
                  comparison = expA - expB;
                  break;
                case "ce":
                  comparison = (dataA.ce?.bid || 0) - (dataB.ce?.bid || 0);
                  break;
                case "pe":
                  comparison = (dataA.pe?.bid || 0) - (dataB.pe?.bid || 0);
                  break;
              }

              return this.currentSort.direction === "asc"
                ? comparison
                : -comparison;
            }
          );

          // Remove existing rows
          rows.forEach((row) => row.remove());

          // Add sorted rows
          sortedStocks.forEach(([stockName]) => {
            this.createStockRow(stockName);
            this.updateRow(stockName);
          });
        }

        startStaleDataCheck() {
          setInterval(() => this.checkStaleData(), 1000);
        }

        checkStaleData() {
          const now = new Date();
          const marketOpen =
            now.getHours() >= 9 &&
            (now.getHours() < 15 ||
              (now.getHours() == 15 && now.getMinutes() < 30));
          this.marketStatus.textContent = marketOpen
            ? "Market Open"
            : "Market Closed";

          this.stockData.forEach((stock, stockName) => {
            const row = document.getElementById(`stock-${stockName}`);
            if (!row) return;

            const isStale = now - (stock.lastUpdate || 0) > 5000; // 5 seconds
            row.classList.toggle("stale", isStale && marketOpen);
          });
        }

        formatTimestamp(date) {
          if (!date) return "";
          const now = new Date();
          const diff = now - date;

          if (diff < 1000) return "just now";
          if (diff < 60000) return `${Math.floor(diff / 1000)}s ago`;
          if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;

          return date.toLocaleTimeString();
        }

        updateStatus(state) {
          this.status.className = state;
          this.status.textContent =
            state.charAt(0).toUpperCase() + state.slice(1);
        }

        connect() {
          this.updateStatus("connecting");
          console.log("Connecting to WebSocket server...");
          const protocol = window.location.protocol === "https:" ? "wss" : "ws";
          const domain = window.location.host;
          const wsUrl = `${protocol}://${domain}/ws`;

          this.ws = new WebSocket(wsUrl);
          this.ws.binaryType = "arraybuffer";

          this.ws.onopen = () => {
            console.log("WebSocket connected");
            this.updateStatus("connected");
            this.reconnectAttempts = 0;
            this.reconnectDelay = 1000;
          };

          this.ws.onmessage = (event) => {
            try {
              this.handleBinaryMessage(event.data);
            } catch (error) {
              console.error("Error handling message:", error);
            }
          };

          this.ws.onclose = (event) => {
            console.log("WebSocket closed:", event.code, event.reason);
            this.updateStatus("disconnected");
            this.reconnect();
          };

          this.ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            this.updateStatus("disconnected");
          };
        }

        reconnect() {
          if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log("Max reconnection attempts reached");
            return;
          }

          this.reconnectAttempts++;
          this.reconnectDelay *= 1.5;
          console.log(
            `Reconnecting in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`
          );
          setTimeout(() => this.connect(), this.reconnectDelay);
        }

        handleBinaryMessage(buffer) {
          try {
            const view = new DataView(buffer);
            let offset = 0;

            const numRecords = view.getUint16(offset, true);
            offset += 2;

            for (let i = 0; i < numRecords; i++) {
              const nameLength = view.getUint8(offset);
              offset += 1;
              const stockName = this.decoder.decode(
                new Uint8Array(buffer, offset, nameLength)
              );
              offset += nameLength;

              const instType = view.getUint8(offset);
              offset += 1;

              const lastPrice = view.getFloat32(offset, true);
              offset += 4;
              const strikePrice = view.getFloat32(offset, true);
              offset += 4;
              const lotSize = view.getFloat32(offset, true);
              offset += 4;
              const bestBid = view.getFloat32(offset, true);
              offset += 4;
              const bestAsk = view.getFloat32(offset, true);
              offset += 4;

              const instrumentType = ["FUT", "CE", "PE"][instType];

              this.updateData({
                stockName,
                instrumentType,
                lastPrice,
                strikePrice,
                lotSize,
                lastUpdate: new Date(),
                depth: {
                  buy: bestBid ? [{ price: bestBid }] : [],
                  sell: bestAsk ? [{ price: bestAsk }] : [],
                },
              });
            }
          } catch (error) {
            console.error("Error parsing binary message:", error);
          }
        }

        updateData(data) {
          if (!this.stockData.has(data.stockName)) {
            this.stockData.set(data.stockName, {
              future: null,
              strike: null,
              ce: null,
              pe: null,
              lotSize: data.lotSize,
              lastUpdate: data.lastUpdate,
            });
            this.createStockRow(data.stockName);
            this.sortAndRenderRows();
          }

          const stock = this.stockData.get(data.stockName);
          const row = document.getElementById(`stock-${data.stockName}`);
          if (!row) return;

          stock.lastUpdate = data.lastUpdate;

          if (data.instrumentType === "FUT") {
            if (data.lastPrice > 0) {
              stock.future = data.lastPrice;
            }
            if (data.lotSize > 0) {
              stock.lotSize = data.lotSize;
            }
            this.updateRow(data.stockName);
          } else {
            if (data.instrumentType === "CE") {
              stock.ce = this.getBestBidAsk(data.depth);
              stock.strike = data.strikePrice;
            } else if (data.instrumentType === "PE") {
              stock.pe = this.getBestBidAsk(data.depth);
              stock.strike = data.strikePrice;
            }
            this.updateRow(data.stockName);
          }
        }

        getBestBidAsk(depth) {
          if (!depth || (!depth.buy.length && !depth.sell.length)) {
            return { bid: null, ask: null };
          }

          const bestBid = depth.buy.length > 0 ? depth.buy[0].price : null;
          const bestAsk = depth.sell.length > 0 ? depth.sell[0].price : null;

          return { bid: bestBid, ask: bestAsk };
        }

        createStockRow(stockName) {
          const row = document.createElement("div");
          row.id = `stock-${stockName}`;
          row.className = "stock-row";
          row.innerHTML = `
            <div>${stockName}</div>
            <div class="future">-</div>
            <div class="strike">-</div>
            <div class="ce">-</div>
            <div class="pe">-</div>
            <div class="lot-size">-</div>
            <div class="exposure">-</div>
          `;
          this.app.appendChild(row);
        }

        updateRow(stockName) {
          const row = document.getElementById(`stock-${stockName}`);
          const stock = this.stockData.get(stockName);
          if (!row || !stock) return;

          const futureEl = row.querySelector(".future");
          const strikeEl = row.querySelector(".strike");
          const ceEl = row.querySelector(".ce");
          const peEl = row.querySelector(".pe");
          const lotEl = row.querySelector(".lot-size");
          const expEl = row.querySelector(".exposure");

          if (stock.future !== null && stock.future > 0) {
            futureEl.textContent = stock.future.toFixed(2);
          }

          if (stock.strike !== null && stock.strike > 0) {
            strikeEl.textContent = stock.strike.toFixed(2);
          }

          if (stock.ce) {
            ceEl.innerHTML = `
              <div class="bid-ask">
                <span class="bid">${stock.ce.bid?.toFixed(2) || "-"}</span>
                <span class="ask">${stock.ce.ask?.toFixed(2) || "-"}</span>
              </div>
            `;
          }

          if (stock.pe) {
            peEl.innerHTML = `
              <div class="bid-ask">
                <span class="bid">${stock.pe.bid?.toFixed(2) || "-"}</span>
                <span class="ask">${stock.pe.ask?.toFixed(2) || "-"}</span>
              </div>
            `;
          }

          if (stock.lotSize > 0) {
            lotEl.textContent = stock.lotSize;
            const exposure = stock.lotSize * stock.future;
            expEl.textContent = this.formatIndianCurrency(exposure);
          }
        }
      }

      // Start the application
      const app = new MarketDataUI();
    </script>
  </body>
</html>
